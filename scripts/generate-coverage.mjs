#!/usr/bin/env node
import { mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import { pathToFileURL } from "node:url";

function parseFeatures(tsPath) {
  const src = readFileSync(tsPath, "utf8");
  const m = src.match(/export default (\{[\s\S]*\}) as const;\n?$/);
  if (!m) throw new Error(`Failed to parse features from ${tsPath}`);
  return JSON.parse(m[1]);
}

function readJson(jsonPath) {
  return JSON.parse(readFileSync(jsonPath, "utf8"));
}
async function importMapping(modulePath) {
  const mod = await import(pathToFileURL(modulePath).href);
  return mod.default || mod;
}

function mapBaseline(b) {
  if (b === "high") return "widely";
  if (b === "low") return "newly";
  if (b === false) return "limited";
  return "unknown";
}

const root = resolve(process.cwd());
const featuresTs = resolve(root, "src/baseline/features.ts");
const mappingModule = resolve(root, "src/baseline/mapping.mjs");
const wfPkgPath = resolve(root, "node_modules/web-features/package.json");

const features = parseFeatures(featuresTs);
const mapping = await importMapping(mappingModule);
let wfVersion = "unknown";
try {
  wfVersion = readJson(wfPkgPath).version || "unknown";
} catch {}

const rows = [];
const featureIds = Object.keys(features);
const mappedIds = Object.keys(mapping);

let mappedCount = 0;

for (const id of featureIds.sort()) {
  const f = features[id];
  const status = f.status || {};
  const bucket = mapBaseline(status.baseline);
  const year = (status.baseline_low_date || status.baseline_high_date || "").slice(0, 4);
  const mapped = mappedIds.includes(id);
  if (mapped) mappedCount++;
  const delegates = mapped
    ? (mapping[id].delegates || []).map((d) => `${d.plugin}:${d.rule}`).join(", ")
    : "";
  rows.push({ id, name: f.name || id, bucket, year, mapped, delegates });
}

const coverage = featureIds.length ? Math.round((mappedCount / featureIds.length) * 100) : 0;

function mdEscape(s) {
  return String(s).replace(/\|/g, "\\|");
}

let md = "";
md += [
  "<!--",
  "  @fileoverview Coverage report generated by scripts/generate-coverage.mjs",
  "  THIS FILE IS AUTOGENERATED. DO NOT EDIT DIRECTLY.",
  "-->",
  "",
].join("\n");
md += "# Baseline Coverage (JavaScript Features)\n\n";
md += `- web-features: [\`v${wfVersion}\`](https://github.com/web-platform-dx/web-features/releases/tag/v${wfVersion})\n`;
md += `- total: \`${featureIds.length}\`\n`;
md += `- mapped: \`${mappedCount}\`\n`;
md += `- coverage: \`${coverage}%\`\n\n`;

md += "| Feature ID | Name | Baseline | Year | Mapped | Delegates |\n";
md += "| --- | --- | --- | --- | --- | --- |\n";
for (const r of rows) {
  md += `| ${mdEscape(r.id)} | ${mdEscape(r.name)} | ${r.bucket} | ${r.year || "-"} | ${r.mapped ? "✅" : "❌"} | ${mdEscape(r.delegates || "-")} |\n`;
}

const outDir = resolve(root, "docs");
mkdirSync(outDir, { recursive: true });
const outPath = resolve(outDir, "coverage.md");
writeFileSync(outPath, md, "utf8");
console.log(`Wrote coverage report to ${outPath}`);
